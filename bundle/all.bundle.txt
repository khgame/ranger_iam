==========
File: cmd/main.go
Time: 2024-04-08 17:40:49
==========
// File: cmd/main.go

package main

import (
	"fmt"
	"log"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"github.com/gin-gonic/gin"

	"github.com/khgame/ranger_iam/internal/util"
	"github.com/khgame/ranger_iam/src/app"
)

// dsn for dev
// todo: using env config
func dsn() string {
	// 使用docker-compose环境变量来设置数据库DSN
	username := "user"
	password := "password"

	// todo: using config
	host := "localhost"
	switch util.Env() {
	case util.RuntimeENVDev:
		host = "mysql"
	case util.RuntimeENVProd:
		host = "mysql"
	case util.RuntimeENVLocal:
		fallthrough
	default:
	}

	port := "3306"
	dbname := "ranger_iam"
	charset := "utf8mb4"
	loc := "Local"
	return fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=%s&parseTime=True&loc=%s", username, password, host, port, dbname, charset, loc)
}

func main() {

	// 初始化数据库连接
	db, err := gorm.Open(mysql.Open(dsn()), &gorm.Config{})
	if err != nil {
		log.Fatal("failed to connect database:", err)
	}

	// 其他程序初始化逻辑...

	// 初始化HTTP路由
	router := gin.Default()

	// 注入db实例到注册处理函数中
	group := router.Group("/api/v1")
	app.RegisterRoutes(group, db) // 注意: RegisterRoutes 函数签名需要接受 *gorm.DB 参数

	// 开启HTTP服务
	router.Run(":8080")
}

==========
File: internal/repository/cache.go
Time: 2024-04-08 17:40:49
==========
// Package repository provides Redis cache logic implementation.
//
// This file was generated by setup_project.sh script.
package repository

// TODO: Implement Redis cache logic implementation.

==========
File: internal/repository/dc.go
Time: 2024-04-08 17:40:49
==========
// Package repository provides distributed configuration center logic implementation.
//
// This file was generated by setup_project.sh script.
package repository

// TODO: Implement distributed configuration center logic implementation.

==========
File: internal/repository/rds.go
Time: 2024-04-08 17:40:49
==========
// Package repository provides ORM-related operations, adapting SQL type databases.
//
// This file was generated by setup_project.sh script.
package repository

// TODO: Implement ORM-related operations, adapting SQL type databases.

==========
File: internal/util/const.go
Time: 2024-04-08 17:40:49
==========
package util

const KEYDegradedMode = "X-Degraded-Mode"
const DegradedModeAll = "1"
const DefaultJWTIssuer = "RANGER_IAM"

==========
File: internal/util/env.go
Time: 2024-04-08 17:40:49
==========
// Package utils provides utility functions for internal use.
//
// This file was generated by setup_project.sh script.
package util

import "os"

// TODO: Implement utility functions for internal use.

const ENVKey = "RANGER_ENV"

const (
	RuntimeENVDev   = "dev"
	RuntimeENVLocal = "local"
	RuntimeENVProd  = "prod"
)

func Env() string {
	return os.Getenv(ENVKey)
}

==========
File: pkg/auth/jwt.go
Time: 2024-04-08 17:40:49
==========
package auth

import (
	"errors"
	"github.com/khicago/irr"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
)

// JwtCustomClaims 包含JWT的声明
type JwtCustomClaims struct {
	UID uint `json:"uid"`
	jwt.StandardClaims
}

// JWTService 提供JWT令牌的服务
type JWTService struct {
	secretKey string
	issuer    string
}

// NewJWTService 创建JWT服务的新实例
func NewJWTService(secretKey, issuer string) *JWTService {
	return &JWTService{
		secretKey: secretKey,
		issuer:    issuer,
	}
}

// GenerateToken 生成JWT令牌
func (s *JWTService) GenerateToken(userID uint) (string, error) {
	// 设置JWT声明
	claims := &JwtCustomClaims{
		userID, // 用户ID从数据库用户模型中带入
		jwt.StandardClaims{
			ExpiresAt: time.Now().Add(time.Hour * 72).Unix(), // 举例：让令牌在72小时后过期
			Issuer:    s.issuer,
		},
	}

	// 使用HMAC SHA256算法进行令牌签名
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	t, err := token.SignedString([]byte(s.secretKey))
	if err != nil {
		return "", err
	}

	return t, nil
}

// ValidateToken performs local token validation using the jwtService
func (s *JWTService) ValidateToken(tokenString string) (*jwt.Token, error) {
	// 解析JWT令牌
	token, err := jwt.ParseWithClaims(tokenString, &JwtCustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		// 在这里验证token方法
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return []byte(s.secretKey), nil
	})

	// 可能存在解析错误或令牌无效错误
	if err != nil {
		return nil, irr.Wrap(err, "token claims parse failed")
	}

	// 返回验证通过的令牌
	if _, ok := token.Claims.(*JwtCustomClaims); ok && token.Valid {
		return token, nil
	} else {
		return nil, errors.New("invalid token")
	}
}

// ValidateClaims performs local token validation using the jwtService, return claims
func (s *JWTService) ValidateClaims(tokenStr string) (*JwtCustomClaims, error) {
	token, err := s.ValidateToken(tokenStr)
	if err != nil {
		return nil, irr.Wrap(err, "token validate failed")
	}

	return token.Claims.(*JwtCustomClaims), nil
}

==========
File: pkg/auth/oauth.go
Time: 2024-04-08 17:40:49
==========
// Package auth provides OAuth-based authentication logic.
//
// This file was generated by setup_project.sh script.
package auth

// TODO: Implement OAuth-based authentication logic.

==========
File: pkg/auth/util.go
Time: 2024-04-08 17:40:49
==========
package auth

import (
	"github.com/gin-gonic/gin"
	"github.com/khicago/irr"
	"strings"
)

const (
	BearerSchema        = "Bearer "
	HeaderAuthorization = "Authorization"
)

// GetTokenStrFromHeader 从 header 里获取 token 字符串
func GetTokenStrFromHeader(c *gin.Context) (string, error) {
	header := c.GetHeader(HeaderAuthorization)
	if header == "" {
		return "", irr.Error("authorization header is required")
	}

	tokenStr := strings.TrimPrefix(header, BearerSchema)
	if tokenStr == header {
		return "", irr.Error("authorization schema is wrong")
	}
	return tokenStr, nil
}

==========
File: pkg/authcli/cli.go
Time: 2024-04-08 17:40:49
==========
package authcli

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/khicago/irr"

	"github.com/khgame/ranger_iam/pkg/auth"
)

const UserCtxKey = "UserID"

var (
	ErrValidateRemoteStatusFailed = irr.Error("validate remote status failed")
	ErrValidateRemoteDegraded     = irr.Error("validate remote degraded")
)

// Cli represents the client used to interact with the IAM server and perform local JWT verification
type Cli struct {
	localJWT    *auth.JWTService
	AuthNSvrURL string

	httpClient *http.Client
}

// New creates a new instance of the IAM client
func New(secretKey, sessionServiceURL string) *Cli {
	jwtService := auth.NewJWTService(secretKey, "UNKNOWN")
	return &Cli{
		localJWT:    jwtService,
		AuthNSvrURL: sessionServiceURL,
		httpClient:  &http.Client{Timeout: 10 * time.Second},
	}
}

// GinMW 创建一个检查 JWT 是否有效的 Gin 中间件
func (cli *Cli) GinMW() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 从 Header 中获取 tokenStr
		tokenStr, err := auth.GetTokenStrFromHeader(c)
		if err != nil {
			// todo: 从 Cookie 中获取 tokenStr
			c.AbortWithStatusJSON(http.StatusUnauthorized, err.Error())
			return
		}

		uid, err := cli.AuthN(c, tokenStr)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, err.Error())
			return
		}
		c.Set(UserCtxKey, uid)
		c.Next()
	}
}

==========
File: pkg/authcli/refresh.go
Time: 2024-04-08 17:40:49
==========
package authcli

import (
	"bytes"
	"encoding/json"
	"errors"

	"net/http"
)

// RefreshToken sends a refresh token request to IAM and returns a new token
func (cli *Cli) RefreshToken(refreshToken string) (string, error) {
	reqBody, err := json.Marshal(map[string]string{"refreshToken": refreshToken})
	if err != nil {
		return "", err
	}

	resp, err := cli.httpClient.Post(cli.AuthNSvrURL+"api/v1/auth/refresh", "application/json",
		bytes.NewBuffer(reqBody),
	)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", errors.New("failed to refresh token")
	}

	var res struct {
		Token string `json:"token"`
	}
	if err = json.NewDecoder(resp.Body).Decode(&res); err != nil {
		return "", err
	}
	return res.Token, nil
}

==========
File: pkg/authcli/validate.go
Time: 2024-04-08 17:40:49
==========
package authcli

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"

	"github.com/khgame/ranger_iam/internal/util"
)

// AuthN 从 jwt 中直接获取 user_id 信息
func (cli *Cli) AuthN(ctx context.Context, tokenStr string) (uint, error) {
	uid, err := cli.ValidateRemote(ctx, tokenStr)
	if err == nil {
		return uid, nil
	}
	if errors.Is(err, ErrValidateRemoteDegraded) || errors.Is(err, ErrValidateRemoteStatusFailed) {
		claims, e := cli.localJWT.ValidateClaims(tokenStr)
		if e != nil {
			return 0, e
		}
		return claims.UID, nil
	}
	return 0, err
}

// ValidateRemote tries to validate the token with the IAM server first.
// If the IAM server is unavailable or gives a degraded response,
// it performs local JWT validation (long term ticket).
// Otherwise, it opts for the short ticket.
func (cli *Cli) ValidateRemote(ctx context.Context, token string) (uint, error) {
	// Try to contact the IAM server
	response, err := cli.httpClient.Get(cli.AuthNSvrURL + "api/v1/session/validate")
	if err != nil || response.StatusCode != http.StatusOK {
		// Server is down or returned a non-ok status - use local validation
		return 0, ErrValidateRemoteStatusFailed
	}

	// Check if the response includes a degradation signal
	// Let's assume the header X-Degraded-Mode indicates the mode
	if response.Header.Get(util.KEYDegradedMode) == util.DegradedModeAll {
		return 0, ErrValidateRemoteDegraded
	}

	// Server response can be used to get userID
	defer response.Body.Close()
	var res struct {
		UID uint `json:"uid"`
	}
	if err = json.NewDecoder(response.Body).Decode(&res); err != nil {
		return 0, err
	}
	return res.UID, nil
}

==========
File: src/app/error_handler.go
Time: 2024-04-08 17:40:49
==========
// Package gw provides HTTP error handling.
//
// This file was generated by setup_project.sh script.
package app

// TODO: Implement HTTP error handling.

==========
File: src/app/routes.go
Time: 2024-04-08 17:40:49
==========
// File: src/app/gw/routes.go

package app

import (
	"github.com/khgame/ranger_iam/internal/util"
	"github.com/khgame/ranger_iam/pkg/auth"
	"github.com/khgame/ranger_iam/src/passport"
	"github.com/khgame/ranger_iam/src/session"
	"gorm.io/gorm"

	"github.com/gin-gonic/gin"
)

// RegisterRoutes - routers all in one
// todo: using rpc
func RegisterRoutes(router gin.IRouter, db *gorm.DB) {

	// todo: 这些值应该从配置中安全获取，现在 MVP 一下
	jwtService := auth.NewJWTService("my_secret_key", util.DefaultJWTIssuer)
	//nwAuth := jwtService.GinMW()

	authGroup := router.Group("/auth")
	{
		svrPassport, _ := passport.Init(db, jwtService)
		svrPassport.ApplyMux(authGroup)
	}

	sessionGroup := router.Group("/session")
	{
		svrPassport, _ := session.Init(db, jwtService)
		svrPassport.ApplyMux(sessionGroup)
	}

}

==========
File: src/model/repo.go
Time: 2024-04-08 17:40:49
==========
package model

import (
	"context"
	"gorm.io/gorm"
)

// Repo 提供用户注册的服务
type Repo struct {
	DB *gorm.DB
}

// NewRepo 创建一个新的RegisterService实例
func NewRepo(db *gorm.DB) *Repo {
	return &Repo{
		DB: db,
	}
}

// RegisterParams 定义注册参数结构体
type RegisterParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

// Register 创建一个新用户
func (repo *Repo) Register(ctx context.Context, params RegisterParams) (*User, error) {
	// 通常你还需要在这里加密密码，这里为了简化示例，我们略过这一步
	// passwordHash := HashPassword(params.Password)

	// 使用Gorm创建新的用户记录
	user, err := repo.createUser(ctx, &User{
		Username:     params.Username,
		Email:        params.Email,
		PasswordHash: params.Password, // 使用passwordHash代替明文密码
	}, nil, nil)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// FindUserByName 用过名字找到一个新用户
func (repo *Repo) FindUserByName(username string) (*User, error) {
	var user User
	err := repo.DB.Where("username = ?", username).First(&user).Error
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func (repo *Repo) createUser(ctx context.Context, user *User, oauth *OAuthCredential, twoFactor *TwoFactorSetting) (*User, error) {

	// 开始数据库事务
	tx := repo.DB.WithContext(ctx).Begin()

	if twoFactor != nil {
		// 首先创建TwoFactorSetting，获取生成的ID
		if err := tx.Create(&twoFactor).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		// 设置用户的TwoFactorID外键
		user.TwoFactorID = twoFactor.ID
	}

	// 接下来创建用户本身
	if err := tx.Create(&user).Error; err != nil {
		tx.Rollback()
		return nil, err
	}

	if oauth != nil {
		// 然后设置OAuthCredential的UserID外键
		oauth.UserID = user.ID

		// 最后创建OAuthCredential条目
		if err := tx.Create(&oauth).Error; err != nil {
			tx.Rollback()
			return nil, err
		}
	}

	// 所有操作成功后提交事务
	if err := tx.Commit().Error; err != nil {
		return nil, err
	}

	// 返回创建的用户对象
	return user, nil
}

==========
File: src/model/user.go
Time: 2024-04-08 17:40:49
==========
package model

import (
	"gorm.io/gorm"
	"time"
)

// User 定义了用户账号管理模块的模型
type User struct {
	gorm.Model          // Includes ID, CreatedAt, UpdatedAt, DeletedAt fields
	Username     string `gorm:"uniqueIndex;not null"`
	Email        string `gorm:"uniqueIndex;not null"`
	PasswordHash string `gorm:"not null"`
	TwoFactorID  uint   `gorm:"column:two_factor_setting_id"` // Reference to two-factor settings
}

type OAuthCredential struct {
	gorm.Model
	UserID     uint   `gorm:"index;not null"`
	User       User   `gorm:"foreignKey:UserID;references:ID"`
	Provider   string `gorm:"not null"` // local, google, facebook, twitter, wechat
	ProviderID string `gorm:"index"`
}

type TwoFactorSetting struct {
	gorm.Model
	IsEnabled      bool
	Phone          string
	SecondaryEmail string
	BackupCodes    string // JSON array of backup codes
}

// BeforeCreate 是Gorm的hook，在创建记录前调用
func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
	if u.CreatedAt.IsZero() {
		u.CreatedAt = time.Now()
	}
	if u.UpdatedAt.IsZero() {
		u.UpdatedAt = time.Now()
	}
	return nil
}

// BeforeUpdate 是Gorm的hook，在更新记录前调用
func (u *User) BeforeUpdate(tx *gorm.DB) (err error) {
	u.UpdatedAt = time.Now()
	return nil
}

==========
File: src/passport/init.go
Time: 2024-04-08 17:40:49
==========
package passport

import (
	"github.com/gin-gonic/gin"
	"github.com/khgame/ranger_iam/pkg/auth"
	"github.com/khgame/ranger_iam/src/model"
	"gorm.io/gorm"
)

type Service struct {
	Repo *model.Repo
	JWT  *auth.JWTService
}

var svr *Service

func Init(db *gorm.DB, jwtService *auth.JWTService) (*Service, error) {
	svr = &Service{
		Repo: model.NewRepo(db),
		JWT:  jwtService,
	}
	return svr, nil
}

func (svr *Service) ApplyMux(group gin.IRouter) {
	group.POST("/register", svr.HandleRegister)
	group.POST("/login", svr.HandleLogin)
}

==========
File: src/passport/login.go
Time: 2024-04-08 17:40:49
==========
// File: src/profile/passport/login_handler.go

package passport

import (
	"errors"
	"net/http"

	"gorm.io/gorm"

	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/bcrypt"
)

// LoginRequest 定义登录请求的结构
type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// HandleLogin 处理登录请求
func (svr *Service) HandleLogin(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload"})
		return
	}

	// 查找用户，验证凭证
	user, err := svr.Repo.FindUserByName(req.Username)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
		}
		return
	}

	// 检查密码是否匹配
	if err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		return
	}

	// 注册成功后生成JWT (short-ticket sample)
	token, err := svr.genJWTTokenAndSetCookie(c.Writer, user.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		return
	}

	// 发送令牌给用户
	c.JSON(http.StatusOK, gin.H{
		"user":  user,
		"token": token,
	})
}

==========
File: src/passport/register.go
Time: 2024-04-08 17:40:49
==========
package passport

import (
	"github.com/gin-gonic/gin"
	"github.com/khgame/ranger_iam/src/model"
	"golang.org/x/crypto/bcrypt"
	"net/http"
)

// RegisterRequest 定义注册请求的结构
type RegisterRequest struct {
	Username        string `json:"username"`
	Email           string `json:"email"`
	Password        string `json:"password"`
	ConfirmPassword string `json:"confirmPassword"`
}

// ErrorMessage 定义错误信息的结构
type ErrorMessage struct {
	Message string `json:"message"`
}

// HandleRegister 处理注册请求
func (svr *Service) HandleRegister(c *gin.Context) {
	var req RegisterRequest

	// 绑定请求体到结构体
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload"})
		return
	}

	// 验证两次输入的密码是否匹配
	if req.Password != req.ConfirmPassword {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Passwords do not match"})
		return
	}

	// 密码加密
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not encrypt password"})
		return
	}

	// 实例化注册服务并进行注册
	user, err := svr.Repo.Register(c, model.RegisterParams{
		Username: req.Username,
		Email:    req.Email,
		Password: string(hashedPassword),
	})

	if err != nil {
		// 处理可能的数据库错误，如唯一性违反等
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user, " + err.Error()})
		return
	}

	// 注册成功后生成JWT (short-ticket sample)
	token, err := svr.genJWTTokenAndSetCookie(c.Writer, user.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token, " + err.Error()})
		return
	}

	// 返回创建成功的用户信息（注意不返回密码等敏感信息）
	c.JSON(http.StatusCreated, gin.H{
		"user":  user,
		"token": token,
	})
}

==========
File: src/passport/util.go
Time: 2024-04-08 17:40:49
==========
package passport

import (
	"net/http"
	"time"
)

func setCookie(w http.ResponseWriter, token string) {
	http.SetCookie(w, &http.Cookie{
		Name:     "token",
		Value:    token,
		Expires:  time.Now().Add(72 * time.Hour),
		HttpOnly: true, // HttpOnly标志确保Javascript无法读取该cookie
	})
}

func (svr *Service) genJWTTokenAndSetCookie(w http.ResponseWriter, userID uint) (token string, err error) {
	token, err = svr.JWT.GenerateToken(userID)
	if err != nil {
		return "", err
	}
	setCookie(w, token)
	return token, nil
}

==========
File: src/session/init.go
Time: 2024-04-08 17:40:49
==========
package session

import (
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"net/http"

	"github.com/khgame/ranger_iam/pkg/auth"
	"github.com/khgame/ranger_iam/src/model"
)

type Service struct {
	Repo *model.Repo
	JWT  *auth.JWTService
}

var svr *Service

func Init(db *gorm.DB, jwtService *auth.JWTService) (*Service, error) {
	svr = &Service{
		Repo: model.NewRepo(db),
		JWT:  jwtService,
	}
	return svr, nil
}

func (svr *Service) ApplyMux(group gin.IRouter) {
	group.GET("/validate", svr.HandleValidate)
}

// HandleValidate 处理验证请求
// 根据策略选择长短票
// 默认长票，降级时下发短票指令
func (svr *Service) HandleValidate(c *gin.Context) {
	token, err := auth.GetTokenStrFromHeader(c)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	claims, err := svr.JWT.ValidateClaims(token)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	// 返回创建成功的用户信息（注意不返回密码等敏感信息）
	c.JSON(http.StatusOK, gin.H{
		"uid": claims.UID,
	})
}

==========
File: src/session/longterm.go
Time: 2024-04-08 17:40:49
==========
// Package session provides long-term session management logic.
//
// This file was generated by setup_project.sh script.
package session

// TODO: Implement long-term session management logic.

==========
File: src/session/shortterm.go
Time: 2024-04-08 17:40:49
==========
// Package session provides short-term session management logic.
//
// This file was generated by setup_project.sh script.
package session

// TODO: Implement short-term session management logic.

==========
File: doc/PROJECT_STRUCTURE.md
Time: 2024-04-08 17:40:49
==========
```
.
├── cmd
│   └── main.go
├── config
│   ├── app.dev.yaml
│   ├── app.prod.yaml
│   ├── log.dev.yaml
│   └── log.prod.yaml
├── deployment
│   ├── migration
│   │   ├── 01.passport_down.sql
│   │   ├── 01.passport_up.sql
│   │   └── migrate.sh
│   ├── Dockerfile
│   └── ci_cd.yaml
├── dev_ranger_iam
│   ├── dial
│   │   ├── auth.http
│   │   └── http-client.env.json
│   └── docker-compose.yml
├── doc
│   └── PROJECT_STRUCTURE.md
├── internal
│   ├── repository
│   │   ├── cache.go
│   │   ├── dc.go
│   │   └── rds.go
│   └── util
│       ├── const.go
│       └── env.go
├── pkg
│   ├── auth
│   │   ├── jwt.go
│   │   ├── oauth.go
│   │   └── util.go
│   └── authcli
│       ├── cli.go
│       ├── refresh.go
│       └── validate.go
├── script
│   └── setup_project.sh
├── src
│   ├── app
│   │   ├── error_handler.go
│   │   └── routes.go
│   ├── model
│   │   ├── repo.go
│   │   └── user.go
│   ├── passport
│   │   ├── init.go
│   │   ├── login.go
│   │   ├── register.go
│   │   └── util.go
│   └── session
│       ├── init.go
│       ├── longterm.go
│       └── shortterm.go
├── LICENSE
├── MODULES.puml
├── Makefile
├── README.md
├── go.mod
└── go.sum
```

==========
File: README.md
Time: 2024-04-08 17:40:49
==========
# Memoria Nexus

Memoria Nexus is an innovative web application designed to optimize your learning process by leveraging the well-researched Ebbinghaus Forgetting Curve. Our system intelligently schedules reviews for study materials, ensuring you retain information over the long term with minimal effort.

## Features

- **Smart Review Scheduling**: Employing Ebbinghaus' Forgetting Curve, Memoria Nexus determines the optimal review times to reinforce memory retention.
- **Customizable Study Material**: Create and manage notes, flashcards, and study sets tailored to your learning preferences.
- **User Progress Analytics**: Get insights into your learning progress with detailed reports and analytics.
- **Interactive Learning**: Engage with educational content through quizzes and interactive sessions.
- **Multi-platform Support**: Access your study materials anytime, anywhere with our responsive web design compatible with both desktop and mobile platforms.
- **Notifications & Reminders**: Never miss a review with timely notifications across multiple devices.

## Getting Started

To start using Memoria Nexus, follow these steps:

1. Sign up for an account at [Memoria Nexus](#).
2. Add your study materials and categorize them based on subjects or topics.
3. Begin your study sessions using our interactive tools.
4. Memoria Nexus will automatically schedule reviews based on your performance.
5. Keep track of your learning journey through our analytics dashboard.

## Technology Stack

Memoria Nexus is built on a robust technology stack ensuring high performance and reliability:

- Frontend: React, Redux, Sass
- Backend: Go, PostgreSQL, Redis
- Infrastructure: Docker, Kubernetes, CI/CD pipelines

see [Code Structure](./doc/CODE_STRUCTURE.md)

## Contributions

We welcome contributions from the community. If you wish to contribute to the project, please check out our [contribution guidelines](./doc/CONTRIBUTING.md).

## License

Memoria Nexus is licensed under the MIT License. See [LICENSE](LICENSE) for more information.

## Connect with Us

Got questions or feedback? Reach out to us via:

- Email: kinghand@foxmail.com
- GitHub: [Memoria Nexus Repository](https://github.com/khgame/ranger_iam)

> Learn smarter, not harder with Memoria Nexus - your nexus of memory and learning!
==========
File: dev_ranger_iam/docker-compose.yml
Time: 2024-04-08 17:40:49
==========
version: '3.8'

services:
  app:
    build:
      context: ..
      dockerfile: ./deployment/Dockerfile
    environment:
      - RANGER_ENV=dev
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
    networks:
      - ranger_iam-net
    entrypoint: [ "/bin/sh", "-c" ] # 覆盖 Dockerfile 的 ENTRYPOINT/CMD
    command: [ "echo 'The app service is started but actual command will be executed manually.' && tail -f /dev/null" ] # 保持容器运行，但不执行应用

  mysql:
    image: mysql:latest
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: example_password
      MYSQL_DATABASE: ranger_iam
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    volumes:
      - mysql-data:/var/lib/mysql
      - ../deployment/migration:/migration
      - ../deployment/migration/migrate.sh:/migrate.sh
    networks:
      - ranger_iam-net

  redis:
    image: redis:latest
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - ranger_iam-net

networks:
  ranger_iam-net:
    driver: bridge

volumes:
  mysql-data:
    driver: local
  redis-data:
    driver: local
==========
File: MODULES.puml
Time: 2024-04-08 17:40:49
==========
@startuml
!define Rectangle class

package "用户账户管理" {
  Rectangle User {
    - id: UUID
    - credentials: UserCredential
    - details: UserDetails
  }
}

package "内容管理" {
  Rectangle StudyItem {
    - topic: Topic
    - content: String
    - category: Category
  }
}

package "记忆曲线算法模块" {
  Rectangle MemoryCurve {
    - calculateOptimalReviewTime(previousReview: DateTime): DateTime
  }
}

package "计划调度器" {
  Rectangle Scheduler {
    - scheduleReviewTasks(user: User): null
  }
}

package "提醒器" {
  Rectangle Reminder {
    - sendNotification(notification: NotificationService): null
  }
}

package "分析和报告" {
  Rectangle AnalyticsReport {
    - generateProgressReport(user: User): Report
  }
}

User --> MemoryCurve : 使用 >
StudyItem --> Scheduler : 被计划 >
Scheduler --> Reminder : 安排提醒 >
Reminder --> User : 通知用户 >
User --> AnalyticsReport : 查看报告 >

@enduml
==========
File: deployment/migration/01.passport_down.sql
Time: 2024-04-08 17:40:49
==========
-- Down migration scripts for [[Profile]] Module

-- Removing the tables created by the 01.passport_up.sql migration
-- migration/01.passport_down.sql

-- Since we didn't create foreign key constraints, table dropping order doesn't matter for constraints,
-- but it's still good practice to reverse the creation order.

-- Dropping the two_factor_settings table
DROP TABLE IF EXISTS `user_two_factor_settings`;

-- Dropping the user_oauth_credentials table
DROP TABLE IF EXISTS `user_oauth_credentials`;

-- Dropping the users table
DROP TABLE IF EXISTS `users`;

-- All the associated tables for the Profile Module's passport feature are now successfully removed.
==========
File: deployment/migration/01.passport_up.sql
Time: 2024-04-08 17:40:49
==========
-- Up migration scripts for [[Profile]] Module

-- Creating the users table
-- migration/01.passport_up.sql

-- 创建 `users` 表，用于管理用户账号信息
CREATE TABLE `users` (
    `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID，自增长',
    `username` VARCHAR(255) UNIQUE NOT NULL COMMENT '用户名，唯一',
    `email` VARCHAR(255) UNIQUE NOT NULL COMMENT '用户邮箱，唯一',
    `password_hash` CHAR(60) NOT NULL COMMENT '用户密码哈希值，用于密码登录验证',

    `two_factor_setting_id` BIGINT UNSIGNED COMMENT 'User 2-factor settings ID',

    -- `created_at`和`updated_at`会由Gorm 自动维护，无需手动插入或更新这些字段。
    `created_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) COMMENT '记录创建时间',
    `updated_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '记录更新时间',

    -- Gorm 默认的软删除是利用`deleted_at`字段，如果该字段有值，则表示记录被软删除。
    `deleted_at` DATETIME(3) COMMENT '记录软删除时间',

    INDEX `idx_users_username` (`username`),
    INDEX `idx_users_email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


-- OAuthCredentials table
CREATE TABLE `user_oauth_credentials` (
    `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `user_id` BIGINT UNSIGNED NOT NULL,
    `provider` ENUM('local', 'google', 'facebook', 'twitter', 'wechat') NOT NULL DEFAULT 'local' COMMENT '账号提供者（本地或社交网络）',
    `provider_id` VARCHAR(255) COMMENT '社交账号提供者的唯一标识',

    INDEX `idx_user_id` (`user_id`),
    INDEX `idx_users_provider_provider_id` (`provider`, `provider_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


-- TwoFactorSettings table
CREATE TABLE `user_two_factor_settings` (
    `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    `is_enabled` BOOLEAN DEFAULT FALSE COMMENT 'Flag indicating if two-factor is enabled',
    `phone` VARCHAR(255) COMMENT 'Phone number for two-factor authentication',
    `secondary_email` VARCHAR(255) COMMENT 'Secondary email for two-factor authentication',
    `backup_codes` TEXT COMMENT 'JSON array of backup codes for two-factor authentication'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

==========
File: .idea/httpRequests/http-requests-log.http
Time: 2024-04-08 17:40:49
==========
GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T173836.401.json

###

GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T173825.401.json

###

POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json
Content-Length: 63
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjEsImV4cCI6MTcxMjgyODIzNCwiaXNzIjoiUkFOR0VSX0lBTSJ9.oqbxd1A1KOIROZDxQU3zkwWXhm7hJ0EBdymA8jM8Hhs
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "password": "strongpassword123"
}

<> 2024-04-08T173817.200.json

###

GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T173721.401.json

###

POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json
Content-Length: 63
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjEsImV4cCI6MTcxMjgyODE4MiwiaXNzIjoiUkFOR0VSX0lBTSJ9.1PdEJn8RWIF4zhQo1G_bgyepKOLoIYIL0Lc2QeftObQ
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "password": "strongpassword123"
}

<> 2024-04-08T173714.200.json

###

GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T173626.401.json

###

POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json
Content-Length: 63
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTczMCwiaXNzIjoiTWVtb3JpYU5leHVzIn0.t7wm3Bq5ka_YuKjtrmXvqNbP18o-HYrk09a575sl_XM
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "password": "strongpassword123"
}

<> 2024-04-08T173622.200.json

###

POST http://0.0.0.0:8080/api/v1/auth/register
Content-Type: application/json
Content-Length: 140
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTcwNCwiaXNzIjoiTWVtb3JpYU5leHVzIn0.2vHDqb6b7kgIlkGR8zzr5sBX0YhBlqRTBwrJG74Yfbo
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "email": "bagaking@example.com",
  "password": "strongpassword123",
  "confirmPassword": "strongpassword123"
}

<> 2024-04-08T173617.500.json

###

POST http://0.0.0.0:8080/api/v1/auth/register
Content-Type: application/json
Content-Length: 140
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTcwNCwiaXNzIjoiTWVtb3JpYU5leHVzIn0.2vHDqb6b7kgIlkGR8zzr5sBX0YhBlqRTBwrJG74Yfbo
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "email": "bagaking@example.com",
  "password": "strongpassword123",
  "confirmPassword": "strongpassword123"
}

<> 2024-04-08T173422.500.json

###

POST http://0.0.0.0:8080/api/v1/auth/register
Content-Type: application/json
Content-Length: 140
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTcwNCwiaXNzIjoiTWVtb3JpYU5leHVzIn0.2vHDqb6b7kgIlkGR8zzr5sBX0YhBlqRTBwrJG74Yfbo
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "email": "bagaking@example.com",
  "password": "strongpassword123",
  "confirmPassword": "strongpassword123"
}

<> 2024-04-08T173257.500.json

###

GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T154944.404.txt

###

GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T154942.404.txt

###

GET http://localhost:8080/api/v1/auth/user
Authorization: Bearer {{ACCESS_TOKEN}}
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTczMCwiaXNzIjoiTWVtb3JpYU5leHVzIn0.t7wm3Bq5ka_YuKjtrmXvqNbP18o-HYrk09a575sl_XM
Accept-Encoding: br,deflate,gzip,x-gzip

<> 2024-04-08T154906.404.txt

###

POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json
Content-Length: 63
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTcxMjgyMTcyMywiaXNzIjoiTWVtb3JpYU5leHVzIn0.ZnvdFhqlgFW437hZ2AqdgfqzhvEhdkvkcKcEfTGZIIo
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "password": "strongpassword123"
}

<> 2024-04-08T154850.200.json

###

POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json
Content-Length: 63
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "password": "strongpassword123"
}

<> 2024-04-08T154843.200.json

###

POST http://0.0.0.0:8080/api/v1/auth/register
Content-Type: application/json
Content-Length: 140
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.5.14 (Java/17.0.7)
Accept-Encoding: br,deflate,gzip,x-gzip

{
  "username": "bagaking",
  "email": "bagaking@example.com",
  "password": "strongpassword123",
  "confirmPassword": "strongpassword123"
}

<> 2024-04-08T154824.201.json

###


==========
File: dev_ranger_iam/dial/auth.http
Time: 2024-04-08 17:40:49
==========
### 注册用户
POST http://0.0.0.0:8080/api/v1/auth/register
Content-Type: application/json

{
  "username": "bagaking",
  "email": "bagaking@example.com",
  "password": "strongpassword123",
  "confirmPassword": "strongpassword123"
}

### 用户登录
POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
  "username": "bagaking",
  "password": "strongpassword123"
}

### 刷新Token
POST http://localhost:8080/api/v1/auth/refresh
Content-Type: application/json
Authorization: Bearer {{ACCESS_TOKEN}}

{}

### 获取用户信息（需要认证）
GET http://localhost:8080/api/v1/session/validate
Authorization: Bearer {{ACCESS_TOKEN}}
==========
File: Makefile
Time: 2024-04-08 17:40:49
==========
# Define the docker-compose command
DC := cd dev_ranger_iam && docker-compose

# Services names
MYSQL_SERVICE := mysql
REDIS_SERVICE := redis
MIGRATION_SERVICE := migration

# Paths
MIGRATE_UP_PATH := migration/migrate_up.sql
MIGRATE_DOWN_PATH := migration/migrate_down.sql

.PHONY: default help gen-doc bundle compose-up compose-down compose-re compose-logs db-migrate-up db-migrate-down db-migrate-re dev build-dev build-app

# Default to help
default: help

# Show help
help:
	@echo "Available commands:"
	@echo "  make compose-up : Start all services with docker-compose"
	@echo "  make compose-down : Stop all services and remove containers"
	@echo "  make compose-logs : Fetch logs for all services"
	@echo "  make db-migrate-up : Perform database migrations"
	@echo "  make db-migrate-down : Rollback database migrations"
	@echo "  make compose-reset : Stop all services and remove data"

gen-doc:
	@echo '```' > ./doc/PROJECT_STRUCTURE.md
	@tree -I 'bundle*' --dirsfirst --noreport >> ./doc/PROJECT_STRUCTURE.md
	@echo '```' >> ./doc/PROJECT_STRUCTURE.md

# bundle, @see github.com/bagaking/file_bundle
bundle: gen-doc
	$(MAKE) -C bundle -f Makefile clean
	$(MAKE) -f bundle/Makefile
	#file_bundle -v -i ./bundle/_.file_bundle_rc -o ./bundle/_.bundle.txt

# Start services
compose-up:
	$(DC) up -d

# Stop services
compose-down:
	$(DC) down

compose-re: compose-down compose-up

# Display logs
compose-logs:
	$(DC) logs

# Existing makefile content
define run-migration
    $(DC) exec $(MYSQL_SERVICE) bash /migrate.sh $(1)
endef
#$(DC) run -T --rm migrator
#$(DC) run --rm -e MIGRATE_DIRECTION=down migrator

db-migrate-up:
	$(call run-migration,up)

db-migrate-down:
	$(call run-migration,down)

db-migrate-re: db-migrate-down db-migrate-up

# Clean up environment including volumes
compose-reset:
	$(DC) down --volumes

# Build the docker image for our go application
build-app: bundle
	$(DC) build app

dev:
	$(DC) up -d app
	@echo Starting app service...
	$(DC) exec -d app /app/ranger_iam
	@echo App service has been started in the background.

# Start the built go application
build-dev: build-app compose-re dev


